<!DOCTYPE html> 
<html> 
<head> 
<title> WebRTC Test Application </title> 
<meta charset="utf-8">
<script src="hcap.js"></script>
<!-- <script src="hcap_api.js"></script> -->
<script>
navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.GetUserMedia || navigator.msGetUserMedia;
windowURL = window.URL || window.webkitURL || window.mozURL || window.msURL;
var request = null;
var hangingGet = null;
var localName;
var server;
var my_id = -1;
var g_peer_id = -1;
var other_peers = {};
var message_counter = 0;
var localVideo;
var remoteVideo;
var localStream;
var started = false;
var signed_In = false;
var mediaTrackConstraints = {'has_audio':true, 'has_video':true};
var isRTCPeerConnection = true;
var notMultiSession = true;
var activeCall = false;
var connectedPeerName;
var connectedPeerId;
var onlyASCII = true;



var localConstraints = {
    audio:true,
    video:{
        mandatory: {
            minWidth: 320,
            minHeight: 240
        }
    }
};
var mediaConstraints = {
    'mandatory': {
        'OfferToReceiveAudio': true,
        'OfferToReceiveVideo': true
    }
};
var sdpConstraints = {
    optional: [{
            DtlsSrtpKeyAgreement: true
        }, {
            RtpDataChannels: true
        }]
};

function AsciiHex2Str(sAsciiHex) {
    var sRes ="";
    if((sAsciiHex.length > 0) && (sAsciiHex.length % 2 == 0 )) {
        var items = sAsciiHex.match(/.{2}/g);
        for (var i = 0; i < items.length; i++) {
            var iItem = parseInt(items[i], 16);
            sRes +=  String.fromCharCode(iItem);
        }
    }
    return sRes;
}
                                                                
function str2AsciiHex(sStr) {
    var sRes = "";
    for (var i = 0; i < sStr.length; i++) {
        sRes += sStr.charCodeAt(i).toString(16).toUpperCase();
    }
    return sRes;
}

function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
    
function AsciiCodes2Str(sAscii) {
    var sRes ="";
    sAscii= sAscii.replace('"','');
    var items = sAscii.split(';');
    for (var i = 0; i < items.length; i++) {
        if(!isNumber(items[i])) {
            break;
        }
        var iItem = parseInt(items[i]);
        sRes +=  String.fromCharCode(iItem);
    }
    return sRes;
}
                                                                       
function str2AsciiCodes(sStr) {
    var sRes = "";
    for (var i = 0; i < sStr.length; i++) {
        sRes += sStr.charCodeAt(i) + ';';
    }
    return sRes;
}
                                                                                               

function trace(txt) {
//    var elem = document.getElementById("debug");
//    elem.innerHTML += txt + "<br>";
    console.log(txt);
}
function keydown(e) {
   if (!e) e = event;

   var code = (e.keyCode ? e.keyCode : e.which);
  
   switch(code) {
	   case hcap.key.Code.UP:
	   case hcap.key.Code.DOWN:	   	
	   case hcap.key.Code.ENTER:	
	   case hcap.key.Code.PORTAL:	
	   case hcap.key.Code.EXIT:	
   }
}
function init_key_listener() {
    if (document.addEventListener) {
       document.addEventListener("keydown",keydown,false);
    } else if (document.attachEvent) {
       document.attachEvent("onkeydown", keydown);
    }
}

function sendMessage(peer_id, message) {
    //console.log("[sendMessage] received message: "+message);
    console.log("[sendMessage] >>>");     
    
    //var msgString = message;
    //var msgString = JSON.stringify(message);^M              
    
    //var str = message;
    //var n = str.indexOf("{"); 
    //var msgString = str.substring(n);
    //message = "";
    
    

    trace("[sendMessage] peer_id:" + peer_id +" C->S: "+ message);
    var xhr = new XMLHttpRequest();
    xhr.open('POST', server + "/message?peer_id=" + my_id + "&to=" + peer_id, true);
    xhr.setRequestHeader("Content-Type", "text/plain");
    xhr.send(message);
    xhr = null;
}

function setLocalAndSendMessage(sessionDescription) {
    trace("[setLocalAndSendMessage]");
 //   trace("[setLocalAndSendMessage] SET LOCAL SDP ");
    //pc.setLocalDescription(sessionDescription);
    
 //   sendMessage(sessionDescription);
}

var CallAnswerErrorCallBack = function(e) {
    trace("Something wrong happened when answer or offer " + e.toString());
};

function doAnswer(peer_id, sdp_msg) {
    trace("[doAnswer]");
    trace("[doAnswer] SEND INCOMING CALL ");
    
    
    hcap.webrtc.incomingCall({
     "localId" : my_id,
     "remoteId" : peer_id,
     "remoteSDP" : sdp_msg,
     "onSuccess" : function() {
         console.log("onSuccess to call outgoingCall");
     }, 
     "onFailure" : function(f) {
         console.log("onFailure : errorMessage = " + f.errorMessage);
     }
});
    
    
    //pc.createAnswer(setLocalAndSendMessage, CallAnswerErrorCallBack, mediaConstraints);

    activeCall = true;
}

function processSignalingMessage(message, peer_id) {
    console.log('processSignalingMessage:' + message);
    try {
    var msg = JSON.parse(message);
//    var msg_encoded = str2AsciiHex(message);
  
    var msg_encoded = message;                                                                      
  
    
    if (msg == null) {
    	    console.log('processSignalingMessage: msg == null');                                                                                                                                                                                    
    	    return;
    }

    console.log("processSignalingMessage [krutogolov] msg:" + msg);
 //   console.log("%s %O", "msg:", msg);
    trace("processSignalingMessage [krutogolov] msg.type=" + msg.type);
    if (msg.type === 'offer') {
        trace('[processSignalingMessage] SET REMOTE SDP');
        doAnswer(peer_id, msg_encoded);
    } else if (msg.type === 'answer' && started) {
        trace('[processSignalingMessage] SEND ACCEPT MESSAGE');
        
        hcap.webrtc.acceptMessage({
					"remoteId" : peer_id,
		      "rtcMsg" : msg_encoded,
		      "onSuccess" : function() {
		         console.log("onSuccess to call incomingCall");
		      }, 
		     "onFailure" : function(f) {
		         console.log("onFailure : errorMessage = " + f.errorMessage);
		     }
				});
        
    } else if (msg.type === 'candidate' && started) {
	trace('[processSignalingMessage] CREATE ICE CANDIDATE AND ADD ICE CANDIDATE');
        hcap.webrtc.acceptMessage({                                                                                                                                                                                      
        		"remoteId" : peer_id,                                                                                                                                                              
        		"rtcMsg" : msg_encoded,                                                                                                                                                                                 
                        "onSuccess" : function() {                                                                                                                                                                              
                        	console.log("onSuccess to call incomingCall");                                                                                                                                                       
                         },                                                                                                                                                                                                     
                         "onFailure" : function(f) {                                                                                                                                                                              
                         	console.log("onFailure : errorMessage = " + f.errorMessage);                                                                                                                                         
                         }                                                                                                                                                                                                        
                       });                                                                                                                                                                                           
    } else if (msg.type === 'bye' && started) {
        console.log("processSignalingMessage [krutogolov] msg:" + msg);
    	hcap.webrtc.acceptMessage({                                                       
                            "remoteId" : peer_id,                                             
                            "rtcMsg" : msg_encoded,                                           
                            "onSuccess" : function() {                                         
                                   console.log("onSuccess to call bye");                      
                            },                                                                
                            "onFailure" : function(f) {                                       
                                   console.log("onFailure call bye: errorMessage = " + f.errorMessage);
                            }                                                                        
                            });       
   
    } else if (msg.type === 'Icallyou') {
        if (!activeCall) {
            if (confirm("Do you accept call from " + other_peers[peer_id] + "?")) {
                sendMessage(peer_id, {type: 'Iagree'});
            } else {
                sendMessage(peer_id, {type: 'Ireject'});
            }
        } else sendMessage(peer_id, {type: 'Imbusy'});
    } else if (msg.type === 'Iagree') {
        document.getElementById("callee").value = other_peers[peer_id];
        document.getElementById("peer_id").value = peer_id;
        doCall();
    } else if (msg.type === 'Ireject') {
        document.getElementById('callee').value = "";
        setButton(false);
        alert("Callee reject you call");
    } else if (msg.type === 'Imbusy') {
        document.getElementById('callee').value = "";
        setButton(false);
        alert("Callee is busy now");
    }
    
    } catch (e) {
    	console.log('processSignalingMessage e:' + e.message());
    }
    
}

function handlePeerMessage(peer_id, data) {
    trace("[handlePeerMessage] peed " + peer_id + " data " + data);
    
    processSignalingMessage(data, peer_id);

    ++message_counter;
    var str = "Message from '" + other_peers[peer_id] + "';";
    str += "<span id='toggle_" + message_counter + "' onclick='toggleMe(this);' ";
    str += "style='cursor: pointer'>+</span><br>";
    str += "<blockquote id='msg_" + message_counter + "' style='display:none'>";
    str += data + "</blockquote>";
    trace(str);
}

function disconnect() {
	trace("[disconnect]");
	    if (request) {
        request.abort();
        request = null;
    }

    if (hangingGet) {
        hangingGet.abort();
        hangingGet = null;
    }

    if (my_id != -1) {
        request = new XMLHttpRequest();
        request.open("GET", server + "/sign_out?peer_id=" + my_id, false);
        request.send();
        request = null;
        my_id = -1;
    }
    document.getElementById("server").disabled = false;
    document.getElementById("local").disabled = false;
//    document.getElementById('debug').innerHTML = '';
//    document.getElementById('callee').value = "";
    
    activeCall = false;
    signed_In = false;
    //clearOtherPeers();
    //showSignInStatus();
    //changeVideoStreamStyles(false);
}

function GetIntHeader(r, name) {
    var val = r.getResponseHeader(name);
    return val != null && val.length ? parseInt(val) : -1;
}

function doCall() {
    trace("[doCall]");

    if (!started && localStream && signed_In) {
       // trace("Creating PeerConnection.");
       // createPeerConnection();
       // trace("Adding local stream.");
       // pc.addStream(localStream);
        trace("started = true");
        started = true;
    }

    setButton(true);

    if (isFirefox) {
        var constraints = {
            "optional": [],
            "mandatory": {
                "mozDontOfferDataChannel": true
            }
        };

        constraints = mergeConstraints(constraints, mediaConstraints);
        trace("Sending offer to peer, with constraints: \n  \"" + JSON.stringify(constraints) + "\".")
        pc.createOffer(setLocalAndSendMessage, CallAnswerErrorCallBack, constraints);
    } else {
        trace("pc.createOffer in doCall().Sending offer to peer, with constraints: \n  \"" + JSON.stringify(mediaConstraints) + "\".");
        pc.createOffer(setLocalAndSendMessage, CallAnswerErrorCallBack, mediaConstraints);
    }
    activeCall = true;
}

function callThisPeer(peer_id) {
	trace("[callThisPeer]");
    outgoingCall(peer_id);
}

function createPeerToCall(name, peerId, elem) {
    console.log("[createPeerToCall krutogolov] name=" + name);
    trace("[createPeerToCall krutogolov] name=" + name);
    var table = document.getElementById("peersLog");
    var rowCount = table.rows.length;

    var row = table.insertRow(rowCount);
    row.setAttribute("name", "peer");
    row.setAttribute("id", "peer" + peerId);
    var newcell0 = row.insertCell(0);
    newcell0.style["witdh"] = "60px";
    newcell0.setAttribute("id", "buttons");
    newcell0.setAttribute("class", "peerInfo");
    if (!activeCall) {
        newcell0.innerHTML = '<button name="call" class="imgbutton" id="' + peerId + '" onclick="callThisPeer(this.id)"> CALL </button>' +
                '<button name="hangup" class="imgbutton" id="hangup" onClick="hangup()" disabled=true>HANG UP</button></td>';
    } else {
        newcell0.innerHTML = '<button name="call" class="imgbutton" id="' + peerId + '" onclick="callThisPeer(this.id)" disabled=true> CALL </button>' +
                '<button name="hangup" class="imgbutton" id="hangup" onClick="hangup()" disabled=true> HANG UP </button></td>';
    }
    var newcell1 = row.insertCell(1);
    newcell1.setAttribute("id", "info");
    newcell1.setAttribute("class", "peerName");
    newcell1.innerHTML = '<b>' + name + '</b>';
}

function updatePeers(add, peerId, name) {
    trace("[updatePeers]" + add + ", peer " + peerId + ", name " + name);
    var peerView = document.getElementById("peersLog");
    if (add) {
        var peerKeys = Object.keys(other_peers);
        if (peerKeys.length == 0) {
            peerView.innerHTML = "";
        }
        if (onlyASCII)
            var decodeName = name;
        else
            var decodeName = decode_utf8(name);
        trace("name = " + name + " decodeName = " + decodeName);
        other_peers[peerId] = decodeName;
        createPeerToCall(decodeName, peerId, peerView);
    } else {
        delete other_peers[peerId];
        //deletePeerRow(peerId);
        var peerKeys = Object.keys(other_peers);
        if (peerKeys.length == 0) {
            peerView.innerHTML = "No available peers.";
        }
    }
    
}

function handleServerNotification(data) {
    trace("[handleServerNotification]: " + data);
    var parsed = data.split(',');
    var peer_id = parseInt(document.getElementById("peer_id").value);
    if (parseInt(parsed[1]) == peer_id && parseInt(parsed[2]) == 0) {
 //       onRemoteHangup();
    }

    var peerId = parseInt(parsed[1]);
    trace("[handleServerNotification] peerId= " + peerId);
g_peer_id = peerId;
    if (parseInt(parsed[2]) != 0) {
        updatePeers(true, peerId, parsed[0]);
    } else {
        if (other_peers[peerId] != "undefined") {
            updatePeers(false, peerId, "");
        }
    }

    trace("[handleServerNotification] number of peers " + Object.keys(other_peers).length);
    trace("[handleServerNotification] otherPeers " + parseInt(parsed[1]) + "=" + parsed[0]);
}

function hangingGetCallback() {
    trace("[hangingGetCallback]");
    try {
        if (hangingGet.readyState != 4)
            return;
        if (hangingGet.status != 200) {
            trace("server error: " + hangingGet.statusText);
            disconnect();
        } else {
            var peer_id = GetIntHeader(hangingGet, "Pragma");
            if (peer_id == my_id) {
                handleServerNotification(hangingGet.responseText);
            } else {
                connectedPeerId = peer_id;
                connectedPeerName = other_peers[peer_id];
                handlePeerMessage(peer_id, hangingGet.responseText);
            }
        }

        if (hangingGet) {
            hangingGet.abort();
            hangingGet = null;
        }

        if (my_id != -1)
            window.setTimeout(startHangingGet, 0);
    } catch (e) {
        trace("Hanging get error: " + e.description);
    }
}

function onHangingGetTimeout() {
    trace("hanging get timeout. issuing again.");
    hangingGet.abort();
    hangingGet = null;
    if (my_id != -1)
        window.setTimeout(startHangingGet, 0);
}

function startHangingGet() {
    trace("[startHangingGet]");
    try {
        hangingGet = new XMLHttpRequest();
        hangingGet.onreadystatechange = hangingGetCallback;
        hangingGet.ontimeout = onHangingGetTimeout;
        hangingGet.open("GET", server + "/wait?peer_id=" + my_id, true);
        hangingGet.send();
    } catch (e) {
        trace("error" + e.description);
    }
}

function signInCallback() {
    trace("[signInCallback]");
    try {
        if (request.readyState == 4) {
            if (request.status == 200) {
                var peers = request.responseText.split("\n");
                my_id = parseInt(peers[0].split(',')[1]);
                
                trace("My id: " + my_id);
                trace("peers: " + peers);
                for (var i = 1; i < peers.length; ++i) {
                    if (peers[i].length > 0) {
                        trace("Peer " + i + ": " + peers[i]);
g_peer_id = i;
                        var parsed = peers[i].split(',');                        
                    }
                }
                                
                startHangingGet();
                request = null;
                signed_In = true;
                showSignInStatus();
                started = true;
            }
        }
    } catch (e) {
        trace("error: " + e.description);
    }
}
function showSignInStatus() {
    var avPeers = document.getElementById("availablePeers");
    var peerData = document.getElementById("idpeersData");
    trace("showPeers signed_In=" + signed_In);
    if (signed_In) {
        avPeers.innerHTML = "Available peers";
        peerData.style["visibility"] = "visible";
        //document.getElementById("connect").disabled = true;
        //document.getElementById("disconnect").disabled = false;
    } else {
        avPeers.innerHTML = "";
        peerData.style["visibility"] = "hidden";
        //document.getElementById("connect").disabled = false;
        //document.getElementById("disconnect").disabled = true;
    }
}

function signIn() {
    trace("[signIn]");
    
    try {
        request = new XMLHttpRequest();
        request.onreadystatechange = signInCallback;
        request.open("GET", server + "/sign_in?" + localName, true);
        request.send();
    } catch (e) {
        trace("error: " + e.description);
    }
}

function connect() {
    trace("[connect]");
    var str = document.getElementById("local").value;
    if (str) {
        if (onlyASCII)
            var test = str;
        else
            var test = encode_utf8(str);

        localName = test;
        server = document.getElementById("server").value.toLowerCase();
        if (localName.length == 0) {
            alert("I need a name please.");
            document.getElementById("local").focus();
        } else {
            signIn();
        }
    } else {
        alert("Please enter you name");
        document.getElementById("local").focus();
    }
}

function outgoingCall(peer_id){
	trace("[outgoingCall] SEND OUTGOINGCALL FOR INITIALIZATION WEBRTC to peer: "+peer_id);  
	var pc_config = {
        "iceServers": [{
                "url": "stun:stun.l.google.com:19302"
            }]
    };
    
    peer_id *= 1;
  hcap.webrtc.outgoingCall({
     "localId" : my_id,
     "remoteId" : peer_id,
     "onSuccess" : function() {
         console.log("onSuccess to call outgoingCall");
     }, 
     "onFailure" : function(f) {
         console.log("onFailure : errorMessage = " + f.errorMessage);
     }
	});
}

function receiveMsgHandler(param){
	trace("[receiveMsgHandler]");
console.log("Event 'webrtc_message_received' is received.\n" +
		             "remotePeerId = " + param.remotePeerId + "\n" +
		             "message = " + param.message );  
	        //sendMessage(param.remotePeerId, param.message);^M                                        

        sendMessage(param.remotePeerId, param.message);                              
	//sendMessage(param.remotePeerId, AsciiHex2Str(param.message));
}

function init(){
	trace("[init]");
	init_key_listener();

		document.getElementById("peersLog").innerHTML = "No available peers.";
    document.getElementById("peersLog").style["left"] = "0px";
    document.getElementById('local').onkeypress=function(e){
        if(e.keyCode==13){
            document.getElementById('connect').click();
        }
    }
    document.addEventListener(
		     "webrtc_message_received",
		     receiveMsgHandler,
		     false
		);
		document.addEventListener(
		     "webrtc_event_received",
		     function (param) {
		     console.log(
		             "Event 'webrtc_event_received' is received.\n" +
		             "eventString = " + param.eventString
		          );  

		     },
		     false
		);

}
window.addEventListener('load', init);

</script>    
</head> 
 
<body margin-left:0; margin-top:0; padding:0">
<table width=100% class="white_box">
<tr>
  <td align=center class="spark"> WebRTC Sample Application </td>
</tr>
<tr>
	<input type='button' id='webrtc' value='webrtc'> 
</tr> 

<div id="idpeers">
    <table><tr><td><input type="text" id="callee" value="" style="visibility:hidden"/>
      <input type="text" id="peer_id" size="3" style="visibility:hidden" />
    </td>
    </tr></table>
    <table><tr>
      <td><div id="idtext">Server</div>
      <input class="input" type="text" id="server" width="200px" value="http://10.40.1.114:8888" /></td>
    </tr>
    <tr>
      <td><div id="idtext">My name</div>
      <input class="input" type="text" id="local" value="TV-AK"  autofocus/></td>
      <td class="idbutton">
      	<button id="connect" onclick="connect();">1Sign in</button>
        <button id="disconnect" onclick="disconnect();">Sign out</button>
        <!--button id="outgoingcall" onclick="outgoingCall();">Call with latest peer</button-->
      </td>
      <td>
      	<button id="startPreviewVideo" onclick="startPreviewVideo();">hcap.webrtc.startPreviewVideo</button>
      	<button id="stopPreviewVideo" onclick="stopPreviewVideo();">hcap.webrtc.stopPreviewVideo</button>
      	<button id="incomingCall" onclick="incomingCall();">hcap.webrtc.incomingCall</button>
      	<button id="outgoingCall" onclick="outgoingCall();">hcap.webrtc.outgoingCall</button>
      	<button id="endCall" onclick="endCall();">hcap.webrtc.endCall</button>      	
    	</td>
    	<td>
      	<button id="startCheckAudio" onclick="startCheckAudio();">hcap.webrtc.startCheckAudio</button>
      	<button id="stopCheckAudio" onclick="stopCheckAudio();">hcap.webrtc.stopCheckAudio</button>
      	<button id="setConfiguration" onclick="setConfiguration();">hcap.webrtc.setConfiguration</button>
      	<button id="getConfiguration" onclick="getConfiguration();">hcap.webrtc.getConfiguration</button>
      	<button id="showDiagnostics" onclick="showDiagnostics();">hcap.webrtc.showDiagnostics</button>      	
      	<button id="acceptMessage" onclick="acceptMessage();">hcap.webrtc.acceptMessage</button>      	
    	</td>
    </tr>
    </table>
    <hr>
    <text id="availablePeers"></text>
    <div id="idpeersData">
      <table id="peersLog">
      </table>
    </div>
  </div>
  
</table>
</body>
</html> 
